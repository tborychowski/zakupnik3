<form ref:form class="form {inEdit ? 'edit' : ''}" on:submit="onsubmit(event)">
	<div class="form-row">
		<input type="hidden" name="id" bind:value="id">
		<textarea autofocus
			ref:textbox
			tabindex="1"
			placeholder="e.g. tesco 12.50"
			autocapitalize="off"
			autocorrect="off"
			on:focus="onfocus()"
			on:input="oninput()"
			on:keydown="onkeydown(event)"
			bind:value="text"></textarea>
	</div>
	<div class="form-footer form-row">
		<button type="button" tabindex="3" class="btn btn-reset" on:click="reset()">Clear</button>
		<button type="button" tabindex="4" class="btn danger btn-remove" on:click="remove()">Remove</button>
		<div class="flex-filler"></div>
		<button type="button" tabindex="3" class="btn btn-cancel" on:click="reset()">Cancel</button>
		<button type="submit" tabindex="2" class="btn success btn-save">Save</button>
		<button type="submit" tabindex="2" class="btn success btn-add">Add</button>
	</div>
</form>

<script>
import Parser from './text-parser';
import {Data, Store} from '../data';


export default {
	store: () => Store,
	data () {
		return {
			inEdit: false,
			id: null,
			text: '',
			rows: [],
		};
	},

	oncreate () {
		this.store.on('state', ({ current, changed, previous }) => {
			if (previous && changed.date) this.parse();
		});

		this.loadGroups();
	},

	computed: {
		_groups ({$groups}) {
			return $groups.map(g => {
				const escaped = g.name.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
				g._name = new RegExp(escaped, 'i');
				return g;
			});
		}
	},

	methods: {
		loadGroups () {
			Data.Groups.get().then(groups => this.store.set({ groups }));
		},

		onfocus () {
			this.parse();
		},

		oninput () {
			this.toggleAmountError();
			this.updateHeight();
			this.parse();
		},

		onkeydown (e) {
			if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) this.onsubmit(e);
			else if (e.key === 'Escape') this.reset(e);
		},

		parse () {
			if (this.parseTimer) clearTimeout(this.parseTimer);
			this.parseTimer = setTimeout(() => {
				const rows = Parser.parse(this.get().text, this.get());
				this.set({ rows });
				this.fire('change', rows);
			}, 300);
		},

		edit (data) {
			this.reset();
			const text = [data.group && data.group.name || '', data.description || '', data.amount].join(' ');
			this.set({ inEdit: true, id: data.id, text });
			this.store.set({ date: data.date })
			this.fire('change', this.get().rows);
		},

		reset () {
			this.set({ inEdit: false, id: null, text: '', rows: [] });
			this.toggleAmountError();
			this.fire('change', []);
			this.updateHeight();
			this.refs.textbox.focus();
		},

		remove () {
			const id = this.get().id;
			Data.Expenses.del(id).then(() => {
				this.reset();
				this.fire('remove');
			});
		},

		onsubmit (e) {
			e.preventDefault();
			const data = this.get();
			const rows = data.rows;
			if (!rows.length) {
				this.toggleAmountError('Please enter amount and category');

				// TODO: toast?
				return this.fire('error', 'Please enter amount and category');
			}
			// item was edited
			if (data.id && rows.length === 1) rows[0].id = data.id;
			const items = rows.map(this.leanItemForSave);
			Data.Expenses.save(items).then(() => {
				this.reset();
				this.fire('submit');
			});
		},

		leanItemForSave (item) {
			return {
				id: item.id,
				date: item.date,
				amount: item.amount,
				description: item.description,
				group_id: item.group_id
			};
		},

		toggleAmountError (msg = '') {
			this.refs.textbox.setCustomValidity(msg);
		},

		updateHeight () {
			const noLines = this.refs.textbox.value.split('\n').length;
			this.refs.textbox.style.height = `${noLines * 1.1}em`;
		},

	}
};
</script>
