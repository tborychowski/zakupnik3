<form ref:form class="form {inEdit ? 'edit' : ''}" on:submit="onsubmit(event)">
	<div class="form-row">
		<input type="hidden" name="id" bind:value="id">
		<textarea autofocus
			ref:textbox
			tabindex="1"
			placeholder="e.g. Tesco 12.50"
			on:input="oninput(this)"
			on:keydown="onkeydown(event)"
			bind:value="text"></textarea>
	</div>
	<div class="form-footer form-row">
		<button type="button" tabindex="3" class="btn btn-reset" on:click="reset()">Clear</button>
		<button type="button" tabindex="4" class="btn danger btn-remove" on:click="remove()">Remove</button>
		<div class="flex-filler"></div>
		<button type="button" tabindex="3" class="btn btn-cancel" on:click="reset()">Cancel</button>
		<button type="submit" tabindex="2" class="btn success btn-save">Save</button>
		<button type="submit" tabindex="2" class="btn success btn-add">Add</button>
	</div>
</form>

<script>
export default {
	data () {
		return {
			inEdit: false,
			date: new Date().toISOString().substr(0, 7),
			id: null,
			text: '',
			groups: [],
			rows: [],
		};
	},
	computed: {
		_groups ({groups}) {
			return groups.map(g => {
				const str = (g.name + ',' + g.keywords).toLowerCase().split(',');
				return { id: g.id, name: g.name, str }
			});
		}
	},

	methods: {
		oninput (el) {
			this.toggleAmountError();
			this.parseEntryText(el.value);
			this.updateHeight();
		},

		onkeydown (e) {
			if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) this.onsubmit(e);
			else if (e.key === 'Escape') this.reset(e);
		},

		edit (data) {
			this.reset();
			this.set({ inEdit: true, text: data });
			this.fire('change', this.get().rows);
		},

		reset () {
			this.set({ inEdit: false, id: null, text: '', rows: [] });
			this.toggleAmountError();
			this.fire('change', []);
			this.updateHeight();
			this.refs.textbox.focus();
		},

		remove () {
			this.fire('remove', { id: this.get().id });
			this.reset();
		},

		onsubmit (e) {
			e.preventDefault();
			const data = this.get();
			const rows = data.rows;
			if (!rows.length) {
				this.toggleAmountError('Please enter amount and category');
				return this.fire('error', 'Please enter amount and category');
			}
			// item was edited
			if (data.id && rows.length === 1) rows[0].id = data.id;
			this.fire('submit', rows);
			this.reset();
		},

		toggleAmountError (msg = '') {
			this.refs.textbox.setCustomValidity(msg);
		},

		updateHeight () {
			const noLines = this.refs.textbox.value.split('\n').length;
			this.refs.textbox.style.height = `${noLines * 1.1}em`;
		},

		parseAmount (amount) {
			/* eslint no-eval: 0 */
			amount = ('' + amount).replace(/\s/g, '');
			if (!(/^[+\-\\*/()\d.]+$/i).test(amount)) return 0;
			if ((/[+\-\\*/.]+/i).test(amount)) {
				try { amount = eval(amount); }
				catch (e) { amount = 0; }
			}
			let num = parseFloat(amount);
			if (num === Infinity || isNaN(num) || num < 0) num = 'error';
			return num;
		},

		getGroup (value) {
			value = value.toLowerCase().trim();
			if (!value) return;
			const groups = this.get()._groups;
			for (const g of groups) {
				if (g.str.indexOf(value) > -1) return g;
			}
			return;
		},

		parseWord (value) {
			if (value.match(/^\d+$/)) return { type: 'amount', value: parseFloat(value), score: 8 };
			if (value.match(/^\d+\.\d+$/)) return { type: 'amount', value: parseFloat(value), score: 9 };
			if (value.match(/^[\d\.()+-/*]+$/)) return { type: 'amount', value: this.parseAmount(value), score: 10 };

			const group = this.getGroup(value);
			if (group && group.id) return { type: 'group', value, group, score: 10 };

			return { type: 'description', value, score: 10 };
		},

		parseRow (row) {
			row = row.replace(/\s+([+-/*()])\s+/g, '$1');  // remove spaces around ops
			const words = row.split(' ').map(w => this.parseWord(w)).sort((a, b) => b.score - a.score);

			const amountIdx = words.findIndex(w => w.type === 'amount');
			const amount = amountIdx > -1 ? words.splice(amountIdx, 1)[0].value : '';

			const groupIdx = words.findIndex(w => w.type === 'group');
			const group = groupIdx > -1 ? words.splice(groupIdx, 1)[0].group : {};

			const description = words.map(w => w.value).join(' ').trim();
			return {amount, description, group, group_id: group.id };
		},

		parseEntryText (val) {
			const rows = val
				.split('\n')
				.map(row => this.parseRow(row))
				.filter(row => row.amount !== '' && row.group_id);

			if (!rows.length) return;

			const date = this.get().date;
			rows.forEach(r => (r.date = date));

			let sum = 0;
			for (let i = 1; i < rows.length; i++) sum += rows[i].amount;
			rows[0].amount -= sum;
			this.set({ rows });
			this.fire('change', rows);
		},
	}
};
</script>
